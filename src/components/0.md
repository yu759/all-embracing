# Commit+Reveal

> **“Frontend Responsibility”** > 

###  Secret Salt：`const salt=web3.utils.randomHex(32);`

### 1.前端计算哈希并提交 (Commit)

**Commit**：
   1. 在前端计算哈希：wishId + salt
  `const commitment = web3.utils.soliditySha3(
    { t: 'uint256', v: wishId },
    { t: 'bytes32', v: secretSalt }
  );`

   2. 发起第一笔交易：只存哈希
  `await myContract.methods.commit(commitment).send({ from: account.value });`
  
   3. 必须存起来！否则 Reveal 阶段就废了
  `localStorage.setItem(`commit_${account.value}`, JSON.stringify({ wishId, secretSalt }));`



### 2.前端揭示数据 (Reveal)

**Reveal**：
 1. 从缓存读取之前的秘密
 ` const data = JSON.parse(localStorage.getItem(`commit_${account.value}`));`
  
 2. 发起第二笔交易：发送明文，让合约校验
  `await myContract.methods.reveal(data.wishId, data.secretSalt).send({ 
    from: account.value 
  });`

### 3. 合约的配合
**Solidity**：`mapping(address => bytes32) public commitments;

function commit(bytes32 _commitment) public {
    commitments[msg.sender] = _commitment; // 存入乱码
}

function reveal(uint256 _wishId, bytes32 _salt) public {
    // 校验：算一下现在的哈希是不是等于之前存的那个
    require(keccak256(abi.encodePacked(_wishId, _salt)) == commitments[msg.sender], "数据不匹配！");
    
    // 校验通过，执行逻辑
    doSomething(_wishId);
    
    // 清除承诺，防止重复使用
    delete commitments[msg.sender];
}`

- **Level 1**：
- **Level 2**
- **Level 3**：

### 第六条：免责声明


---